// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.command.local;

import com.pulumi.asset.Archive;
import com.pulumi.asset.AssetOrArchive;
import com.pulumi.command.Utilities;
import com.pulumi.command.local.CommandArgs;
import com.pulumi.command.local.enums.Logging;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * A local command to be executed.
 * 
 * This command can be inserted into the life cycles of other resources using the `dependsOn` or `parent` resource options. A command is considered to have failed when it finished with a non-zero exit code. This will fail the CRUD step of the `Command` resource.
 * 
 * ## Example Usage
 * 
 * ### Basic Example
 * 
 * This example shows the simplest use case, simply running a command on `create` in the Pulumi lifecycle.
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.command.local.Command;
 * import com.pulumi.command.local.CommandArgs;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var random = new Command("random", CommandArgs.builder()
 *             .create("openssl rand -hex 16")
 *             .build());
 * 
 *         ctx.export("rand", random.stdout());
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Invoking a Lambda during Pulumi Deployment
 * 
 * This example show using a local command to invoke an AWS Lambda once it&#39;s deployed. The Lambda invocation could also depend on other resources.
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.aws.iam.Role;
 * import com.pulumi.aws.iam.RoleArgs;
 * import com.pulumi.aws.lambda.Function;
 * import com.pulumi.aws.lambda.FunctionArgs;
 * import com.pulumi.command.local.Command;
 * import com.pulumi.command.local.CommandArgs;
 * import static com.pulumi.codegen.internal.Serialization.*;
 * import com.pulumi.resources.CustomResourceOptions;
 * import com.pulumi.asset.FileArchive;
 * import java.util.Map;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var awsConfig = ctx.config("aws");
 *         var awsRegion = awsConfig.require("region");
 * 
 *         var lambdaRole = new Role("lambdaRole", RoleArgs.builder()
 *                 .assumeRolePolicy(serializeJson(
 *                         jsonObject(
 *                                 jsonProperty("Version", "2012-10-17"),
 *                                 jsonProperty("Statement", jsonArray(jsonObject(
 *                                         jsonProperty("Action", "sts:AssumeRole"),
 *                                         jsonProperty("Effect", "Allow"),
 *                                         jsonProperty("Principal", jsonObject(
 *                                                 jsonProperty("Service", "lambda.amazonaws.com")))))))))
 *                 .build());
 * 
 *         var lambdaFunction = new Function("lambdaFunction", FunctionArgs.builder()
 *                 .name("f")
 *                 .publish(true)
 *                 .role(lambdaRole.arn())
 *                 .handler("index.handler")
 *                 .runtime("nodejs20.x")
 *                 .code(new FileArchive("./handler"))
 *                 .build());
 * 
 *         // Work around the lack of Output.all for Maps in Java. We cannot use a plain Map because
 *         // `lambdaFunction.arn()` is an Output<String>.
 *         var invokeEnv = Output.tuple(
 *                 Output.of("FN"), lambdaFunction.arn(),
 *                 Output.of("AWS_REGION"), Output.of(awsRegion),
 *                 Output.of("AWS_PAGER"), Output.of("")
 *         ).applyValue(t -> Map.of(t.t1, t.t2, t.t3, t.t4, t.t5, t.t6));
 * 
 *         var invokeCommand = new Command("invokeCommand", CommandArgs.builder()
 *                 .create(String.format(
 *                         "aws lambda invoke --function-name \"$FN\" --payload '{\"stackName\": \"%s\"}' --cli-binary-format raw-in-base64-out out.txt >/dev/null && cat out.txt | tr -d '\"'  && rm out.txt",
 *                         ctx.stackName()))
 *                 .environment(invokeEnv)
 *                 .build(),
 *                 CustomResourceOptions.builder()
 *                         .dependsOn(lambdaFunction)
 *                         .build());
 * 
 *         ctx.export("output", invokeCommand.stdout());
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Using Triggers
 * 
 * This example defines several trigger values of various kinds. Changes to any of them will cause `cmd` to be re-run.
 * 
 * <pre>
 * {@code
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         final var fileAssetVar = new FileAsset("Pulumi.yaml");
 * 
 *         var rand = new RandomString("rand", RandomStringArgs.builder()
 *             .length(5)
 *             .build());
 * 
 *         var localFile = new Command("localFile", CommandArgs.builder()
 *             .create("touch foo.txt")
 *             .archivePaths("*.txt")
 *             .build());
 * 
 *         var cmd = new Command("cmd", CommandArgs.builder()
 *             .create("echo create > op.txt")
 *             .delete("echo delete >> op.txt")
 *             .triggers(
 *                 rand.result(),
 *                 fileAssetVar,
 *                 localFile.archive())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 */
@ResourceType(type="command:local:Command")
public class Command extends com.pulumi.resources.CustomResource {
    /**
     * If the previous command&#39;s stdout and stderr (as generated by the prior create/update) is
     * injected into the environment of the next run as PULUMI_COMMAND_STDOUT and PULUMI_COMMAND_STDERR.
     * Defaults to true.
     * 
     */
    @Export(name="addPreviousOutputInEnv", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> addPreviousOutputInEnv;

    /**
     * @return If the previous command&#39;s stdout and stderr (as generated by the prior create/update) is
     * injected into the environment of the next run as PULUMI_COMMAND_STDOUT and PULUMI_COMMAND_STDERR.
     * Defaults to true.
     * 
     */
    public Output<Optional<Boolean>> addPreviousOutputInEnv() {
        return Codegen.optional(this.addPreviousOutputInEnv);
    }
    /**
     * An archive asset containing files found after running the command.
     * 
     */
    @Export(name="archive", refs={Archive.class}, tree="[0]")
    private Output</* @Nullable */ Archive> archive;

    /**
     * @return An archive asset containing files found after running the command.
     * 
     */
    public Output<Optional<Archive>> archive() {
        return Codegen.optional(this.archive);
    }
    /**
     * A list of path globs to return as a single archive asset after the command completes.
     * 
     * When specifying glob patterns the following rules apply:
     * - We only include files not directories for assets and archives.
     * - Path separators are `/` on all platforms - including Windows.
     * - Patterns starting with `!` are &#39;exclude&#39; rules.
     * - Rules are evaluated in order, so exclude rules should be after inclusion rules.
     * - `*` matches anything except `/`
     * - `**` matches anything, _including_ `/`
     * - All returned paths are relative to the working directory (without leading `./`) e.g. `file.text` or `subfolder/file.txt`.
     * - For full details of the globbing syntax, see [github.com/gobwas/glob](https://github.com/gobwas/glob)
     * 
     * #### Example
     * 
     * Given the rules:
     * 
     * When evaluating against this folder:
     * 
     * The following paths will be returned:
     * 
     */
    @Export(name="archivePaths", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> archivePaths;

    /**
     * @return A list of path globs to return as a single archive asset after the command completes.
     * 
     * When specifying glob patterns the following rules apply:
     * - We only include files not directories for assets and archives.
     * - Path separators are `/` on all platforms - including Windows.
     * - Patterns starting with `!` are &#39;exclude&#39; rules.
     * - Rules are evaluated in order, so exclude rules should be after inclusion rules.
     * - `*` matches anything except `/`
     * - `**` matches anything, _including_ `/`
     * - All returned paths are relative to the working directory (without leading `./`) e.g. `file.text` or `subfolder/file.txt`.
     * - For full details of the globbing syntax, see [github.com/gobwas/glob](https://github.com/gobwas/glob)
     * 
     * #### Example
     * 
     * Given the rules:
     * 
     * When evaluating against this folder:
     * 
     * The following paths will be returned:
     * 
     */
    public Output<Optional<List<String>>> archivePaths() {
        return Codegen.optional(this.archivePaths);
    }
    /**
     * A list of path globs to read after the command completes.
     * 
     * When specifying glob patterns the following rules apply:
     * - We only include files not directories for assets and archives.
     * - Path separators are `/` on all platforms - including Windows.
     * - Patterns starting with `!` are &#39;exclude&#39; rules.
     * - Rules are evaluated in order, so exclude rules should be after inclusion rules.
     * - `*` matches anything except `/`
     * - `**` matches anything, _including_ `/`
     * - All returned paths are relative to the working directory (without leading `./`) e.g. `file.text` or `subfolder/file.txt`.
     * - For full details of the globbing syntax, see [github.com/gobwas/glob](https://github.com/gobwas/glob)
     * 
     * #### Example
     * 
     * Given the rules:
     * 
     * When evaluating against this folder:
     * 
     * The following paths will be returned:
     * 
     */
    @Export(name="assetPaths", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> assetPaths;

    /**
     * @return A list of path globs to read after the command completes.
     * 
     * When specifying glob patterns the following rules apply:
     * - We only include files not directories for assets and archives.
     * - Path separators are `/` on all platforms - including Windows.
     * - Patterns starting with `!` are &#39;exclude&#39; rules.
     * - Rules are evaluated in order, so exclude rules should be after inclusion rules.
     * - `*` matches anything except `/`
     * - `**` matches anything, _including_ `/`
     * - All returned paths are relative to the working directory (without leading `./`) e.g. `file.text` or `subfolder/file.txt`.
     * - For full details of the globbing syntax, see [github.com/gobwas/glob](https://github.com/gobwas/glob)
     * 
     * #### Example
     * 
     * Given the rules:
     * 
     * When evaluating against this folder:
     * 
     * The following paths will be returned:
     * 
     */
    public Output<Optional<List<String>>> assetPaths() {
        return Codegen.optional(this.assetPaths);
    }
    /**
     * A map of assets found after running the command.
     * The key is the relative path from the command dir
     * 
     */
    @Export(name="assets", refs={Map.class,String.class,AssetOrArchive.class}, tree="[0,1,2]")
    private Output</* @Nullable */ Map<String,AssetOrArchive>> assets;

    /**
     * @return A map of assets found after running the command.
     * The key is the relative path from the command dir
     * 
     */
    public Output<Optional<Map<String,AssetOrArchive>>> assets() {
        return Codegen.optional(this.assets);
    }
    /**
     * The command to run once on resource creation.
     * 
     * If an `update` command isn&#39;t provided, then `create` will also be run when the resource&#39;s inputs are modified.
     * 
     * Note that this command will not be executed if the resource has already been created and its inputs are unchanged.
     * 
     * Use `local.runOutput` if you need to run a command on every execution of your program.
     * 
     */
    @Export(name="create", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> create;

    /**
     * @return The command to run once on resource creation.
     * 
     * If an `update` command isn&#39;t provided, then `create` will also be run when the resource&#39;s inputs are modified.
     * 
     * Note that this command will not be executed if the resource has already been created and its inputs are unchanged.
     * 
     * Use `local.runOutput` if you need to run a command on every execution of your program.
     * 
     */
    public Output<Optional<String>> create() {
        return Codegen.optional(this.create);
    }
    /**
     * The command to run on resource delettion.
     * 
     * The environment variables `PULUMI_COMMAND_STDOUT` and `PULUMI_COMMAND_STDERR` are set to the stdout and stderr properties of the Command resource from previous create or update steps.
     * 
     */
    @Export(name="delete", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> delete;

    /**
     * @return The command to run on resource delettion.
     * 
     * The environment variables `PULUMI_COMMAND_STDOUT` and `PULUMI_COMMAND_STDERR` are set to the stdout and stderr properties of the Command resource from previous create or update steps.
     * 
     */
    public Output<Optional<String>> delete() {
        return Codegen.optional(this.delete);
    }
    /**
     * The directory from which to run the command from. If `dir` does not exist, then
     * `Command` will fail.
     * 
     */
    @Export(name="dir", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> dir;

    /**
     * @return The directory from which to run the command from. If `dir` does not exist, then
     * `Command` will fail.
     * 
     */
    public Output<Optional<String>> dir() {
        return Codegen.optional(this.dir);
    }
    /**
     * Additional environment variables available to the command&#39;s process.
     * 
     */
    @Export(name="environment", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> environment;

    /**
     * @return Additional environment variables available to the command&#39;s process.
     * 
     */
    public Output<Optional<Map<String,String>>> environment() {
        return Codegen.optional(this.environment);
    }
    /**
     * The program and arguments to run the command.
     * On Linux and macOS, defaults to: `[&#34;/bin/sh&#34;, &#34;-c&#34;]`. On Windows, defaults to: `[&#34;cmd&#34;, &#34;/C&#34;]`
     * 
     */
    @Export(name="interpreter", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> interpreter;

    /**
     * @return The program and arguments to run the command.
     * On Linux and macOS, defaults to: `[&#34;/bin/sh&#34;, &#34;-c&#34;]`. On Windows, defaults to: `[&#34;cmd&#34;, &#34;/C&#34;]`
     * 
     */
    public Output<Optional<List<String>>> interpreter() {
        return Codegen.optional(this.interpreter);
    }
    /**
     * If the command&#39;s stdout and stderr should be logged. This doesn&#39;t affect the capturing of
     * stdout and stderr as outputs. If there might be secrets in the output, you can disable logging here and mark the
     * outputs as secret via &#39;additionalSecretOutputs&#39;. Defaults to logging both stdout and stderr.
     * 
     */
    @Export(name="logging", refs={Logging.class}, tree="[0]")
    private Output</* @Nullable */ Logging> logging;

    /**
     * @return If the command&#39;s stdout and stderr should be logged. This doesn&#39;t affect the capturing of
     * stdout and stderr as outputs. If there might be secrets in the output, you can disable logging here and mark the
     * outputs as secret via &#39;additionalSecretOutputs&#39;. Defaults to logging both stdout and stderr.
     * 
     */
    public Output<Optional<Logging>> logging() {
        return Codegen.optional(this.logging);
    }
    /**
     * The standard error of the command&#39;s process
     * 
     */
    @Export(name="stderr", refs={String.class}, tree="[0]")
    private Output<String> stderr;

    /**
     * @return The standard error of the command&#39;s process
     * 
     */
    public Output<String> stderr() {
        return this.stderr;
    }
    /**
     * Pass a string to the command&#39;s process as standard in
     * 
     */
    @Export(name="stdin", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> stdin;

    /**
     * @return Pass a string to the command&#39;s process as standard in
     * 
     */
    public Output<Optional<String>> stdin() {
        return Codegen.optional(this.stdin);
    }
    /**
     * The standard output of the command&#39;s process
     * 
     */
    @Export(name="stdout", refs={String.class}, tree="[0]")
    private Output<String> stdout;

    /**
     * @return The standard output of the command&#39;s process
     * 
     */
    public Output<String> stdout() {
        return this.stdout;
    }
    /**
     * The resource will be updated (or replaced) if any of these values change.
     * 
     * The trigger values can be of any type.
     * 
     * If the `update` command was provided the resource will be updated, otherwise it will be replaced using the `create` command.
     * 
     * Please see the resource documentation for examples.
     * 
     */
    @Export(name="triggers", refs={List.class,Object.class}, tree="[0,1]")
    private Output</* @Nullable */ List<Object>> triggers;

    /**
     * @return The resource will be updated (or replaced) if any of these values change.
     * 
     * The trigger values can be of any type.
     * 
     * If the `update` command was provided the resource will be updated, otherwise it will be replaced using the `create` command.
     * 
     * Please see the resource documentation for examples.
     * 
     */
    public Output<Optional<List<Object>>> triggers() {
        return Codegen.optional(this.triggers);
    }
    /**
     * The command to run when the resource is updated.
     * 
     * If empty, the create command will be executed instead.
     * 
     * Note that this command will not run if the resource&#39;s inputs are unchanged.
     * 
     * Use `local.runOutput` if you need to run a command on every execution of your program.
     * 
     * The environment variables `PULUMI_COMMAND_STDOUT` and `PULUMI_COMMAND_STDERR` are set to the `stdout` and `stderr` properties of the Command resource from previous create or update steps.
     * 
     */
    @Export(name="update", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> update;

    /**
     * @return The command to run when the resource is updated.
     * 
     * If empty, the create command will be executed instead.
     * 
     * Note that this command will not run if the resource&#39;s inputs are unchanged.
     * 
     * Use `local.runOutput` if you need to run a command on every execution of your program.
     * 
     * The environment variables `PULUMI_COMMAND_STDOUT` and `PULUMI_COMMAND_STDERR` are set to the `stdout` and `stderr` properties of the Command resource from previous create or update steps.
     * 
     */
    public Output<Optional<String>> update() {
        return Codegen.optional(this.update);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Command(java.lang.String name) {
        this(name, CommandArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Command(java.lang.String name, @Nullable CommandArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Command(java.lang.String name, @Nullable CommandArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("command:local:Command", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Command(java.lang.String name, Output<java.lang.String> id, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("command:local:Command", name, null, makeResourceOptions(options, id), false);
    }

    private static CommandArgs makeArgs(@Nullable CommandArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? CommandArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Command get(java.lang.String name, Output<java.lang.String> id, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Command(name, id, options);
    }
}
