// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as enums from "../types/enums";
import * as utilities from "../utilities";

/**
 * Copy an Asset or Archive to a remote host.
 *
 * ## Example usage
 *
 * This example copies a local directory to a remote host via SSH. For brevity, the remote server is assumed to exist, but it could also be provisioned in the same Pulumi program.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import { remote, types } from "@pulumi/command";
 * import * as fs from "fs";
 * import * as os from "os";
 * import * as path from "path";
 *
 * export = async () => {
 *     const config = new pulumi.Config();
 *
 *     // Get the private key to connect to the server. If a key is
 *     // provided, use it, otherwise default to the standard id_rsa SSH key.
 *     const privateKeyBase64 = config.get("privateKeyBase64");
 *     const privateKey = privateKeyBase64 ?
 *         Buffer.from(privateKeyBase64, 'base64').toString('ascii') :
 *         fs.readFileSync(path.join(os.homedir(), ".ssh", "id_rsa")).toString("utf8");
 *
 *     const serverPublicIp = config.require("serverPublicIp");
 *     const userName = config.require("userName");
 *
 *     // The configuration of our SSH connection to the instance.
 *     const connection: types.input.remote.ConnectionArgs = {
 *         host: serverPublicIp,
 *         user: userName,
 *         privateKey: privateKey,
 *     };
 *
 *     // Set up source and target of the remote copy.
 *     const from = config.require("payload")!;
 *     const archive = new pulumi.asset.FileArchive(from);
 *     const to = config.require("destDir")!;
 *
 *     // Copy the files to the remote.
 *     const copy = new remote.CopyToRemote("copy", {
 *         connection,
 *         source: archive,
 *         remotePath: to,
 *     });
 *
 *     // Verify that the expected files were copied to the remote.
 *     // We want to run this after each copy, i.e., when something changed,
 *     // so we use the asset to be copied as a trigger.
 *     const find = new remote.Command("ls", {
 *         connection,
 *         create: `find ${to}/${from} | sort`,
 *         triggers: [archive],
 *     }, { dependsOn: copy });
 *
 *     return {
 *         remoteContents: find.stdout
 *     }
 * }
 * ```
 */
export class CopyToRemote extends pulumi.CustomResource {
    /**
     * Get an existing CopyToRemote resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, opts?: pulumi.CustomResourceOptions): CopyToRemote {
        return new CopyToRemote(name, undefined as any, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'command:remote:CopyToRemote';

    /**
     * Returns true if the given object is an instance of CopyToRemote.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is CopyToRemote {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === CopyToRemote.__pulumiType;
    }

    /**
     * The parameters with which to connect to the remote host.
     */
    public readonly connection!: pulumi.Output<outputs.remote.Connection>;
    /**
     * The destination path on the remote host. The last element of the path will be created if it doesn't exist but it's an error when additional elements don't exist. When the remote path is an existing directory, the source file or directory will be copied into that directory. When the source is a file and the remote path is an existing file, that file will be overwritten. When the source is a directory and the remote path an existing file, the copy will fail.
     */
    public readonly remotePath!: pulumi.Output<string>;
    /**
     * An [asset or an archive](https://www.pulumi.com/docs/concepts/assets-archives/) to upload as the source of the copy. It must be path-based, i.e., be a `FileAsset` or a `FileArchive`. The item will be copied as-is; archives like .tgz will not be unpacked. Directories are copied recursively, overwriting existing files.
     */
    public readonly source!: pulumi.Output<pulumi.asset.Asset | pulumi.asset.Archive>;
    /**
     * Trigger replacements on changes to this input.
     */
    public readonly triggers!: pulumi.Output<any[] | undefined>;

    /**
     * Create a CopyToRemote resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: CopyToRemoteArgs, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (!opts.id) {
            if ((!args || args.connection === undefined) && !opts.urn) {
                throw new Error("Missing required property 'connection'");
            }
            if ((!args || args.remotePath === undefined) && !opts.urn) {
                throw new Error("Missing required property 'remotePath'");
            }
            if ((!args || args.source === undefined) && !opts.urn) {
                throw new Error("Missing required property 'source'");
            }
            resourceInputs["connection"] = args?.connection ? pulumi.secret((args.connection ? pulumi.output(args.connection).apply(inputs.remote.connectionArgsProvideDefaults) : undefined)) : undefined;
            resourceInputs["remotePath"] = args ? args.remotePath : undefined;
            resourceInputs["source"] = args ? args.source : undefined;
            resourceInputs["triggers"] = args ? args.triggers : undefined;
        } else {
            resourceInputs["connection"] = undefined /*out*/;
            resourceInputs["remotePath"] = undefined /*out*/;
            resourceInputs["source"] = undefined /*out*/;
            resourceInputs["triggers"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["connection"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        const replaceOnChanges = { replaceOnChanges: ["triggers[*]"] };
        opts = pulumi.mergeOptions(opts, replaceOnChanges);
        super(CopyToRemote.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * The set of arguments for constructing a CopyToRemote resource.
 */
export interface CopyToRemoteArgs {
    /**
     * The parameters with which to connect to the remote host.
     */
    connection: pulumi.Input<inputs.remote.ConnectionArgs>;
    /**
     * The destination path on the remote host. The last element of the path will be created if it doesn't exist but it's an error when additional elements don't exist. When the remote path is an existing directory, the source file or directory will be copied into that directory. When the source is a file and the remote path is an existing file, that file will be overwritten. When the source is a directory and the remote path an existing file, the copy will fail.
     */
    remotePath: pulumi.Input<string>;
    /**
     * An [asset or an archive](https://www.pulumi.com/docs/concepts/assets-archives/) to upload as the source of the copy. It must be path-based, i.e., be a `FileAsset` or a `FileArchive`. The item will be copied as-is; archives like .tgz will not be unpacked. Directories are copied recursively, overwriting existing files.
     */
    source: pulumi.Input<pulumi.asset.Asset | pulumi.asset.Archive>;
    /**
     * Trigger replacements on changes to this input.
     */
    triggers?: pulumi.Input<any[]>;
}
